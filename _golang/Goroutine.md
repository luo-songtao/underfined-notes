---
title: Goroutine
author: 罗松涛
category: golang
layout: post
---

## 前言

#### 进程

进程是"程序执行的一个实例",担当分配系统资源的实体,进程创建必须分配一个完整的独立地址空间！

进程是系统资源分配的最小单位,系统由一个个进程(程序)组成,一般情况下,包括文本区域

进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多个进程的实现则是通过CPU飞快的切换不同进程,因此看上去就像多个进程在同时进行

> 由于进程间是隔离的,各自拥有自己的内存资源,因此相对线程比较安全,所以不同进程之间的数据只能通过 IPC(Inter-Process Communication) 进行通信共享!

#### 线程

维基百科：线程（英语：thread）是操作系统能够进行**运算调度**的最小单位。

线程是进程中活动的对象,每个线程都拥有一个独立的程序计数器,进程栈和一组进程寄存器! 内核调度的对象是线程,而不是进程! Linux系统的线程实现非常特别: 它对线程和进程并不特别区分,对Linux而言,线程只不过是一种特殊的进程罢了

线程上下文一般只包含CPU上下文及其他的线程管理信息,线程创建的开销主要取决于线程堆栈的建立而分配内存的开销等并不大

线程上下文切换发生在两个线程需要同步的时候,比如进入共享数据段。切换指CPU寄存器值需要存储,并随后用将要切换到的线程的原先存储的值重新加载到CPU寄存器中去

> 进程相当于一个容器,线程是运行在容器里面的,所以容器内的东西,线程是共享的,因此线程间的通信可以直接通过全局变量进行通信! 但也因此会有很多安全的问题! 另外,一个线程崩溃了,会导致整个进程也崩溃了!

#### 协程

> 本处的协程指的是操作系统层面的!并不是Golang里的 协程 望注意!

维基百科: 协程是计算机程序的一类组件，推广了协作式多任务的子程序，允许执行被挂起与被恢复。相对子例程而言，协程更为一般和灵活，但在实践中使用没有子例程那样广泛。协程更适合于用来实现彼此熟悉的程序组件，如协作式多任务、异常处理、事件循环、迭代器、无限列表和管道。

术语: coroutine

协程可以通过yield来调用其它协程。通过yield方式转移执行权的协程之间不是调用者与被调用者的关系，而是彼此对称、平等的。

协程的起始处是第一个入口点，在协程里，返回点之后是接下来的入口点。

子例程的生命期遵循后进先出（最后一个被调用的子例程最先返回）；相反，协程的生命期完全由他们的使用的需要决定。

为啥要用协程？协程有助于实现:
- 状态机: 在一个子例程里实现状态机,这里状态由该过程当前的出口/入口点确定个,这可以产生可读性更高的代码
- 角色模型：并行的角色模型，例如计算机游戏。每个角色有自己的过程（这又在逻辑上分离了代码），但他们自愿地向顺序执行各角色过程的中央调度器交出控制（这是合作式多任务的一种形式）。
- 产生器：它有助于输入／输出和对数据结构的通用遍历。


#### 进程和线程的上下文切换

进程切换分为3步:

- 切换页目录以使用新的地址空间
- 切换内核栈
- 切换硬件上下文

线程切换只需要第2,3步,因此进程的切换代价比较大

#### 线程和协程的区别

一旦创建完线程,你就无法决定他什么时候获得时间片,什么时候会让出时间片了,你把它交给了内核!

而协程编写者可以有 一是可控的切换时机! 二是很小的切换代价!

从操作系统有没有调度权上看,协程就是因为不需要进程内核态的切换! 所以会使用它,会有这么个东西! 协程- 用户态的轻量级的线程


## 1. Kernel是如何调度线程的

在Linux中，线程是由进程来实现，线程就是轻量级进程（ lightweight process ），因此在Linux中，线程的调度是按照进程的调度方式来进行调度的，也就是说线程是调度单元。

Linux这样实现的线程的好处的之一是：线程调度直接使用进程调度就可以了，没必要再搞一个进程内的线程调度器。

在Linux中，调度器是基于线程的调度策略（scheduling policy）和静态调度优先级（static scheduling priority）来决定那个线程来运行。

对于下面三种调度策略SCHED_OTHER, SCHED_IDLE, SCHED_BATCH，其调度优先级sched_priority是不起作用的，即可以看成其调度优先级为0；调度策略SCHED_FIFO和SCHED_RR是实时策略，他们的调度值范围是1到99，数值越大优先级越高，另外实时调度策略的线程总是比前面三种通常的调度策略优先级更高。

通常，调度器会为每个可能的调度优先级（sched_priority value）维护一个可运行的线程列表，并且是以最高静态优先级列表头部的线程作为下次调度的线程。所有的调度都是抢占式的：如果一个具有更高静态优先级的线程转换为可以运行了，那么当前运行的线程会被强制进入其等待的队列中。下面介绍几种常见的调度策略：

- SCHED_OTHER： 该策略是是默认的Linux分时调度（time-sharing scheduling）策略，它是Linux线程默认的调度策略。SCHED_OTHER策略的静态优先级总是为0，对于该策略列表上的线程，调度器是基于动态优先级（dynamic priority）来调度的，动态优先级是跟nice中相关(nice值可以由接口nice, setpriority,sched_setattr来设置)，该值会随着线程的运行时间而动态改变，以确保所有具有SCHED_OTHER策略的线程公平运行。在Linux上，nice值的范围是-20到+19，默认值为0；nice值越大则优先级越低，相比高nice值（低优先级）的进程，低nice值（高优先级）的进程可以获得更多的处理器时间。使用命令ps -el查看系统的进程列表，其中NI列就是进程对应的nice值；使用top命令，看到的NI列也是nice值。运行命令的时候可用nice –n xx cmd来调整cmd任务的nice值，xx的范围是-20~19之间。

- SCHED_FIFO： 先入先出调度策略（First in-first out scheduling）。该策略简单的说就是一旦线程占用cpu则一直运行，一直运行直到有更高优先级任务到达或自己放弃。

- SCHED_RR： 时间片轮转调度(Round-robin scheduling)。该策略是SCHED_FIFO基础上改进来的，他给每个线程增加了一个时间片限制，当时间片用完后，系统将把该线程置于队列末尾。放在队列尾保证了所有具有相同优先级的RR任务的调度公平。使用top命令，如果PR列的值为RT，则说明该进程采用的是实时策略，即调度策略是SCHED_FIFO或者为SCHED_RR，而对于非实时调度策略（比如SCHED_OTHER）的进程，该列的值是NI+20，以供Linux内核使用。


## 2. Golang的Goroutine

Go为了提供更容易使用的并发方法，使用了goroutine和channel。

goroutine来自协程的概念，让一组可复用的函数运行在一组线程之上，即使有协程阻塞，该线程的其他协程也可以被runtime调度，转移到其他可运行的线程上。最关键的是，程序员看不到这些底层的细节，这就降低了编程的难度，提供了更容易的并发。

Go中，协程被称为goroutine（Rob Pike说goroutine不是协程，因为他们并不完全相同），它非常轻量，一个goroutine只占几KB，并且这几KB就足够goroutine运行完，这就能在有限的内存空间内支持大量goroutine，支持了更多的并发。虽然一个goroutine的栈只占几KB，但实际是可伸缩的，如果需要更多内容，runtime会自动为goroutine分配。

“一个Goroutine是一个与其他goroutines 并发运行在同一地址空间的Go函数或方法。一个运行的程序由一个或更多个goroutine组成。它与线程、协程、进程等不同。它是一个goroutine。”

### 3. goroutine 和 thread 的区别

goroutine白话: Goroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread，我们只会看到代码里满天飞的 goroutine。操作系统却相反，管你什么 goroutine，我才没空理会。我安心地执行线程就可以了，线程才是我调度的基本单位。

那 goroutine 与 thread的区别呢?

- 内存占用

    创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。
    
    对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。

- 创建和销毁

    Thread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。

- 切换

    当 threads 切换时，需要保存各种寄存器，以便将来恢复：
    > 16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.

    而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。

    一般而言，线程切换会消耗 1000-1500 纳秒，一个纳秒平均可以执行 12-18 条指令。所以由于线程切换，执行指令的条数会减少 12000-18000。

    Goroutine 的切换约为 200 ns，相当于 2400-3600 条指令。

    因此，goroutines 切换成本比 threads 要小得多。

## 4. Golang的调度器

操作系统调度器会将系统中的多个线程按照一定算法调度到物理CPU上去运行。

传统的编程语言比如C、C++等的并发实现实际上就是基于操作系统调度的，即程序负责创建线程(一般通过pthread等lib调用实现)，操作系统负责调度。


Go采用了用户层轻量级thread或者说是类coroutine的概念来解决这些问题，Go将之称为”goroutine“

goroutine占用的资源非常小(Go 1.4将每个goroutine stack的size默认设置为2k)


goroutine调度的切换也不用陷入(trap)操作系统内核层完成，代价很低。因此，一个Go程序中可以创建成千上万个并发的goroutine。所有的Go代码都在goroutine中执行，哪怕是go的runtime也不例外。将这些goroutines按照一定算法放到“CPU”上执行的程序就称为**goroutine调度器**或**goroutine scheduler**。


不过，一个Go程序对于操作系统来说只是一个用户层程序。goroutine的调度全要靠Go自己完成，实现Go程序内goroutine之间“公平”的竞争“CPU”资源，这个任务就落到了Go runtime头上

于是Goroutine的调度问题就演变为go runtime如何将程序内的众多goroutine按照一定算法调度到“CPU”资源上运行了。

在操作系统层面，Thread竞争的“CPU”资源是真实的物理CPU，但在Go程序层面，各个Goroutine要竞争的”CPU”资源是什么呢？

Go程序是用户层程序，它本身整体是运行在一个或多个操作系统线程上的，因此goroutine们要竞争的所谓“CPU”资源就是操作系统线程。这样Go scheduler的任务就明确了：将goroutines按照一定算法放到不同的操作系统线程中去执行。这种在语言层面自带调度器的，我们称之为原生支持并发。

### 4.1 并发模型的实现原理

再说调度器之前,先说下几个线程模型的实现,方便理解!

内核空间主要操作访问CPU资源、I/O资源、内存资源等硬件资源，为上层应用程序提供最基本的基础资源

用户空间就是上层应用程序的固定活动空间，用户空间不可以直接访问资源，必须通过“系统调用”、“库函数”或“Shell脚本”来调用内核空间提供的资源。

我们现在的计算机语言，可以狭义的认为是一种“软件”，它们中所谓的“线程”，往往是用户态的线程，和操作系统本身内核态的线程（简称KSE），还是有区别的。

#### 用户级线程模型

多个用户态的线程对应着一个内核线程，程序线程的创建、终止、切换或者同步等线程工作必须自身来完成

#### 内核级线程模型
这种模型直接调用操作系统的内核线程，所有线程的创建、终止、切换、同步等操作，都由内核来完成。C++就是这种


#### 两级线程模型

这种模型是介于用户级线程模型和内核级线程模型之间的一种线程模型

这种模型的实现非常复杂，和内核级线程模型类似，一个进程中可以对应多个内核级线程，但是进程中的线程不和内核线程一一对应；这种线程模型会先创建多个内核级线程，然后用自身的用户级线程去对应的创建多个内核级线程，自身的用户级线程需要本身程序去调度，内核级的线程交给操作系统内核去调度。

Go语言的线程模型就是一种特殊的两级线程模型。

### 4.2 老调度器 G-M模型

2012年3月28日，Go 1.0正式发布

每个goroutine对应于runtime中的一个抽象结构：G

而os thread作为“物理CPU”的存在而被抽象为一个结构：M(machine)

G-M模型的一个重要不足： 限制了Go并发程序的伸缩性，尤其是对那些有高吞吐或并行计算需求的服务程序

### 4.3 新调度器 G-P-M模型

G-P-M调度模型和work stealing算法

